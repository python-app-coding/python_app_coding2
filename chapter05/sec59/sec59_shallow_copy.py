# coding: utf8

"""
1）使用切片可以实现列表的部分复制，如果列表的元素是不可变对象，则复制是完全的，复杂情况下一般是浅复制：
 >>> u = [1, 2, 3]		# 被复制的列表为单层次的（所有元素为不可变对象）
 >>> v = u[:]              		# 使用切片得到新的列表
 >>> v, id(v), id(u)       		# 切片返回的是不同对象
 ([1, 2, 3], 1932658041480, 1932658039432)
 >>> v[0] = 100            		# 改变切片对象的元素
 >>> u, v                  		# 没有影响到原列表的元素（u的第0个元素仍然为1）
 ([1, 2, 3], [100, 2, 3])

 >>> u = [1, 2, [1, 2]]  		# 如果u是一个多层列表，第2个元素为可变容器对象
 >>> v = u[:]		# 使用切片复制
 >>> v[2][0] = 100        		# 改变副本的内层列表的值
 >>> u, v                		# 原列表也发生了变化，说明切片复制是浅复制！
 ([1, 2, [100, 2]], [1, 2, [100, 2]])

2）使用内置类型转换函数可以实现复制，但一般情况下，都是浅复制：
 >>> a = {'name': 'Wang', 'score': [100, 90, 85]}
 >>> b = dict(a)               	# 使用字典函数复制一个字典
 >>> id(b), id(a)           		# 复制产生了新的对象
 (1932658016760, 1932610625040)

 >>> b['name'] = 'Li'         	    # 改变b中键'name'的值
 >>> a, b                     		# 只有b的值发生了变化，字典函数是一个复制！
 ({'name': 'Wang', 'score': [100, 90, 85]}, {'name': 'Li', 'score': [100, 90, 85]})

 >>> b['score'][0] = 200       	    # 改变字典b的'score'列表中的值
 >>> a, b                     		# 两个字典score的值都发生了变化，这个复制是浅复制！
 ({'name': 'Wang', 'score': [200, 90, 85]}, {'name': 'Li', 'score': [200, 90, 85]})

可变容器类型list、dict、set对应的同名创建函数可以实现复制，而str、tuple类型为不可变类型，只实现引用。
3）一些类型的copy方法可以实现复制，对多层次复杂对象，实现的仍然是浅层复制：
 >>> a = {'name': 'Wang', 'score': [100, 90, 85]}
 >>> c = a.copy()             	    # 通过copy方法，可以创建一个字典的副本
 >>> c['name'] = 'Sun'        	    # 改变副本c的内容
 >>> a, c                     		# 没有影响到a的内容（第一层次！）
 ({'name': 'Wang', 'score': [100, 90, 85]}, {'name': 'Sun', 'score': [100, 90, 85]})

 >>> c['score'][0] = 300      	    # 改变score的值，会影响到a的score的值
 >>> c, a                     		# copy方法是浅复制，没有对列表的元素进行复制
 ({'name': 'Sun', 'score': [300, 90, 85]}, {'name': 'Wang', 'score': [300, 90, 85]})


 # 浅层复制
 >>> import copy
 >>> x = [1, [2, [3, [4, 5]]]]     # 多次结构对象
 >>> y = copy.copy(x)              # 使用模块copy的浅复制方法copy进行复制
 >>> y[1][1][1][0] = 1000          # 改变列表y的深层结构中的内容
 >>> x                             # 列表x随之改变
 [1, [2, [3, [1000, 5]]]]

# 实现深度复制
 >>> z = copy.deepcopy(x)         # 对x进行深度复制
 >>> z[1][1][1][0]= 2000          # 改变副本中的深层次对象值
 >>> z
 [1, [2, [3, [2000, 5]]]]
 >>> x                            # 原列表对象没有改变
 [1, [2, [3, [1000, 5]]]]

# 对于字符串、元组一类的不可变对象，深度复制方法只建立引用
 >>> s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
 >>> t = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
 >>> tt = (1, (2, (3, (4, 5))))
 >>> s1, t1, tt1 = copy.deepcopy(s), copy.deepcopy(t), copy.deepcopy(tt)
 >>> id(s), id(s1)         # 字符串的深度复制没有建立新的对象
 (1932658393456, 1932658393456)
 >>> id(t), id(t1)         # 元组的深度复制没有建立新的对象
 (1932657912136, 1932657912136)
 >>> id(tt), id(tt1)       # 多层不可变对象的深度复制没有建立新的对象
 (1932657999304, 1932657999304)

 # 字符串乘以常数形成的短字符串可以驻留:
 >>> ss1 = 'abc12345'*512		# 长度8*512=4096，生成的字符串对象驻留内存
 >>> ss2 = 'abc12345'*512		# 第二个生成的字符串变量为与ss1相同的引用
 >>> print('id(ss1)=', id(ss1), 'id(ss2)=', id(ss2))
 id(ss1)=1932633758736, id(ss2)=1932633758736

 >>> xs1 = 'a_123'*820		# 长度5*820=4100>4096, 会生成不同的对象
 >>> xs2 = 'a_123'*820
 >>> print('id(xs1)=', id(xs1), 'id(xs2)=', id(xs2))
 id(xs1)=1932633793680, id(xs2)=1932633763104

# 长度超过4096的字符串，不能驻留:
 >>> ls1 = 'abc123'*683      	# 长度超过4096, 赋值后会产生不同的字符串对象
 >>> ls2 = 'abc123'*683
 >>> print('id(ls1)==id(ls2):', id(ls1)==id(ls2),  id(ls1), id(ls2))
 id(ls1)==id(ls2): False,  1932633798048, 1932633771840

# 使用变量乘以字符串时，除了0和1之外，都不会驻留:
 >>> v0, v1 = 0, 1
 >>> vs01 = 'abc123'*v0                   # 任何字符串乘以0产生空串，驻留内存
 >>> vs02 = 'abc123'*v0
 >>> print('id(vs01)=', id(vs01), 'id(vs02)=', id(vs02))
 id(vs01)=1932565904496, id(vs02)=1932565904496

 >>> vs11 = 'abc123'*v1                   # 字符串乘以1，不改变原串，驻留内存
 >>> vs12 = 'abc123'*v1
 >>> print('id(vs11)=', id(vs11), 'id(vs12)=', id(vs12))
 id(vs11)=1932658259816, id(vs12)=1932658259816

 >>> vi = 2                            # 变量>=2时，产生的字符串不驻留内存
 >>> vs1 = 'abc123'*vi
 >>> vs2 = 'abc123'*vi
 >>> print('id(vs1)=', id(vs1), 'id(vs2)=', id(vs2))
 id(vs1)=1932658291120, id(vs2)=1932658291952


 >>> a, b = [1], [1]
 >>> a.append(b)
 >>> b.append(a)
 >>> print(a, b)
 [1, [1, [...]]] [1, [1, [...]]]

 # >>> a == b
 # Traceback (most recent call last):
 # ......
 #  a == b
 # RecursionError: maximum recursion depth exceeded in comparison
 # # 递归错误：在比较运算中超过了（系统允许的）最大递归深度
"""